# 拦截器
Interceptord的类型
RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。
BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。
CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。
ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。
CallServerInterceptor：和服务器通信，完成Http请求。
这些都是okhttp库内部定义的拦截器



拦截器是一个非常强大的机制，可以监视，重写和重试call。这里是一个简单的拦截器，用来打印出去的请求和收到的响应。

```Plain Text
class LoggingInterceptor implements Interceptor {
  @Override public Response intercept(Interceptor.Chain chain) throws IOException {
    Request request = chain.request();

    long t1 = System.nanoTime();
    logger.info(String.format("Sending request %s on %s%n%s",
        request.url(), chain.connection(), request.headers()));

    Response response = chain.proceed(request);

    long t2 = System.nanoTime();
    logger.info(String.format("Received response for %s in %.1fms%n%s",
        response.request().url(), (t2 - t1) / 1e6d, response.headers()));

    return response;
  }
}

```
调用chain.proceed(request)是每个拦截器实现的一个主要部分。这个简单的方法是HTTP工作发生，产出满足请求的响应之处，

拦截器可以链接。假如有一个压缩拦截器和一个检验和拦截器：你需要决定是先数据进行压缩然后检验和，还是先检验和然后进行压缩。
OkHttp使用列表来跟踪拦截器，并且拦截器按顺序被调用。



## 应用拦截器
拦截器可以注册为应用拦截器和网络拦截器。我们使用上面定义的LoggingInterceptor来展示它们的不同。

通过在OkHttpCleint.Builder上调用addInterceptor()来注册一个应用拦截器：

```Plain Text
OkHttpClient client = new OkHttpClient.Builder()
    .addInterceptor(new LoggingInterceptor())
    .build();

Request request = new Request.Builder()
    .url("http://www.publicobject.com/helloworld.txt")
    .header("User-Agent", "OkHttp Example")
    .build();

Response response = client.newCall(request).execute();
response.body().close();

```
[http://www.publicobject.com/helloworld.txt](https://link.jianshu.com?t=http://www.publicobject.com/helloworld.txt)这个URL重定向到[https://publicobject.com/helloworld.txt](https://link.jianshu.com?t=https://publicobject.com/helloworld.txt)，OkHttp会自动跟进这个重定向。我们的应用拦截器会被调用一次，并且从chain.proceed()返回的响应是重定向后的响应：

```Plain Text
INFO: Sending request http://www.publicobject.com/helloworld.txt on null
User-Agent: OkHttp Example

INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms
Server: nginx/1.4.6 (Ubuntu)
Content-Type: text/plain
Content-Length: 1759
Connection: keep-alive

```
我看可以看到我们已经重定向了，引文reponse.request().url()与request.url()不同。两个日志语句打印了两个不同的URL。

## 网络拦截器
注册一个网络拦截器很相似。调用addNetworkInterceptor()替代addInterceptor():

```Plain Text
OkHttpClient client = new OkHttpClient.Builder()
    .addNetworkInterceptor(new LoggingInterceptor())
    .build();

Request request = new Request.Builder()
    .url("http://www.publicobject.com/helloworld.txt")
    .header("User-Agent", "OkHttp Example")
    .build();

Response response = client.newCall(request).execute();
response.body().close();

```
当我们运行这个代码，拦截器会执行两次。一次是访问[http://www.publicobject.com/helloworld.txt](https://link.jianshu.com?t=http://www.publicobject.com/helloworld.txt)的初始请求，另外一个是重定向到[https://publicobject.com/helloworld.txt](https://link.jianshu.com?t=https://publicobject.com/helloworld.txt)。

```Plain Text
INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}
User-Agent: OkHttp Example
Host: www.publicobject.com
Connection: Keep-Alive
Accept-Encoding: gzip

INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms
Server: nginx/1.4.6 (Ubuntu)
Content-Type: text/html
Content-Length: 193
Connection: keep-alive
Location: https://publicobject.com/helloworld.txt

INFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}
User-Agent: OkHttp Example
Host: publicobject.com
Connection: Keep-Alive
Accept-Encoding: gzip

INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms
Server: nginx/1.4.6 (Ubuntu)
Content-Type: text/plain
Content-Length: 1759
Connection: keep-alive

```
网络请求也包含更多数据，例如通过OkHttp添加的Accept-Encoding:gzip头来通知支持响应压缩。
网络拦截器的Chain有一个非空Connection，可以用来访问IP地址和用来连接网络服务器的TLS配置。

