package javatest.jvm.虚拟机类型;

public class hotspot {
    /**
     * 1.线程栈：线程创建是会为每个线程创建一个线程栈，线程栈里面会为每个方法调用创建一个栈帧。主要用于保存线程的当前运行状态。
     *
     * 2.堆：用于存放运行时中生成的新对像。会划分成新生代和老年代。新生代里面又划分成了eden区、存活1区和存活2区。
     *
     * 3.永久区：方法和常量区，用于存放方法字节码元数据和各种常量。
     */

    /**
     * 触发GC的时机
     *
     * 最后总结一下什么时候会触发一次GC，个人经验看，有三种场景会触发GC：
     *
     * 1、第一种场景应该很明显，当年轻代或者老年代满了，Java虚拟机无法再为新的对象分配内存空间了，
     * 那么Java虚拟机就会触发一次GC去回收掉那些已经不会再被使用到的对象
     *
     * 2、手动调用System.gc_old()方法，通常这样会触发一次的Full GC以及至少一次的Minor GC
     *
     * 3、程序运行的时候有一条低优先级的GC线程，它是一条守护线程，当这条线程处于运行状态的时候，
     * 自然就触发了一次GC了。这点也很好证明，不过要用到WeakReference的知识，后面写WeakReference的时候会专门讲到这个。
     */

}
