引用计数算法：互相引用无法回收
根搜索算法
可以作为 GC Roots 的对象
• 虚拟机栈正在运行使用的引用
• 静态属性 常量
• JNI 引用的对象
GC 是需要 2 次扫描才回收对象，所以我们可以使用 finalize 去救活丢失的引用，不推荐使用，降低gc效率

```
@Override
    protected void finalize() throws Throwable {
        super.finalize();
        instace = this;
    }
```

## 强引用

如果一个对象具有强引用，那垃圾回收器绝不会回收它，当内存空间不足， Java 虚拟机宁愿抛出 OOM 错误，使程序异常 Crash ,
也不会靠随意回收具有强引用的对象来解决内存不足的问题.

## 软引用

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；
如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用。
软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，
java 虚拟机就会把这个软引用加入到与之关联的引用队列中。

```
当一个WeakReference开始返回null时，它所指向的对象变成了垃圾，这个WeakReference对象本身几乎也没什么用了。
这意味着有一些清除工作需要做。
例如，WeakHashMap不得不移除掉这样的死掉的键值对以避免包含越来越多死掉的WeakReference。

ReferenceQueue使得跟踪死掉的引用变得简单。
如果你给WeakReference的构造方法传入一个ReferenceQueue，那么当这个WeakReference的对象所指向的对象成为垃圾的时候，
这个WeakReference对象将会被插入这个ReferenceQueue。
接下来，你可以隔一段时间就处理一下ReferenceQueue，做一些对死掉的WeakReference任何你想做的清理工作。
```

ReferenceQueue是专门用来存放引用的, 当软引用,弱引用,虚引用对应的那个对象被回收后的同时,该引用会自动加入到你所定义的ReferenceQueue中.

## 弱引用

弱引用与软引用的区别在于: 只具有弱引用的对象拥有更短暂的生命周期。
在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，
都会回收它的内存。不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

## 虚引用

GC如果发现对象只是被虚幻引用，在第一轮的时候就可以立即回收这个对象。而你可以在任何方便的时候清理资源。

1. 每次垃圾回收时都会被回收，主要用于监测对象是否已经从内存中删除
2. 虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中
3. 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
